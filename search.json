[{"categories":null,"content":"Basing a package manager and related specification on bash is a mistake. Familiarity and hackability are great in the short-term, but as the novelty wears off it becomes clear that maintainability, efficiency, and other attributes hard to wrest from bash’s rigid design all suffer. As long as compatibility remains important for pkgcraft that decision can’t be altered; however, that doesn’t mean nothing can be done to improve the situation.\nOne option is to go pkgcore’s route, using IPC with a bash daemon. This enables sharing bash processes between separate tasks rather than relying on a simplistic exec-per-use scheme. Among other effects, this makes pkgcore’s metadata generation approximately five times faster than its main competitor. While providing many marginal improvements, this daemonized approach still doesn’t escape the restrictive boundaries of regular shell usage. Among other downsides, pkgcore requires subshells (meaning additional processes) to avoid environment leaks during metadata generation and uses hacky RPC signaling across pipes since it’s hard to work with anything else natively in bash.\nPkgcraft aims to move beyond daemon functionality and achieve better lower level integration. The dream of replacing bash with something threadable and modern is enticing, but it’s fairly impossible in the short-term and thus disregarded. Instead, pkgcraft dives directly into the pit of insanity; it forks bash1 in an effort to achieve its goals.\nParallelism problems Since pkgcraft goes to the extent of forking bash, it also takes on the various deficiencies that hinder its use as a library. For a start, bash is not thread-safe or reentrant at all. The current design uses an extensive amount of global mutables to track both its parser and shell state. Bash uses bison which supports generating reentrant parsers, but the shell itself requires extensive rework for that to be feasible on a global scale.\nWith that in mind, in order to support parallel usage a process pool or similar design must be used. Currently this isn’t something that can easily be dropped into place like python’s multiprocessing pool support. Parallelism in rust centers around threading since its memory safety through enforced lifetimes highlights threaded execution that’s guaranteed data-race free. This means that most data parallelism crates similar to rayon only support threaded operation, disregarding multi-process support entirely. At some point, pkgcraft will have to address this and probably create its own pool or parallelized iterator support that reuses processes.\nError handling Beyond parallelism issues, bash leverages longjmp() and frame unwinding for its error handling. This is understandable due to its age, chosen language, and minimal dependencies, but it doesn’t lend itself well to interoperability with rust. For pkgcraft, bash is wrapped where its C code is called from the rust library and then it can call back into rust support exported to C. The issue with that is unwinding across rust-based frames from C is undefined behavior. Hopefully at some point the “C-unwind” ABI2 and other related FFI work in rust makes it into stable.\nWith respect to longjmp() usage, in order to avoid null jump buffers the forked version of bash tries to establish jump targets on the main entry points used by the rust library. This isn’t necessary for standard bash because its top level jump points are all in main() which isn’t used when built as a library. Without this, most error handling segfaults when using set -e because bash tries to jump to an empty jump buffer.\nTo cap off its unfriendly error handling, bash generally dumps all its error messages to stderr. Clearly this isn’t wanted when used as a library, especially when parallelized. To avoid this, the rust library passes in callbacks for error and warning handling that bash calls, passing the raw messages back to rust which are then converted into native rust errors or logged.\nThe remaining issue is that unless something like set -e is being used on the bash side, most errors do not cause immediate returns, exits, or any trigger that could be used on the rust side to return a corresponding error result. To work around this, the most recent bash error is stored on the rust side in a thread-local variable that can be accessed after relevant calls in order to determine their error status. This allows functionality such as returning error results on failed source calls while retaining the bash error message without having to use set -e, subshells, and redirection in order to achieve a similar effect in native bash.\nLeveraging builtins In terms of extensibility, bash provides support for writing builtins that can be called like any other command. For example, set, local, echo, and many more commands provided by bash are builtins. Pkgcraft intends to use builtins for all the commands that would either be exposed as functions or other public callables. All other internal functionality will be implemented as methods on the shell instance wrapping the bash library.\nThe difficulty comes with sharing state across the FFI border since the builtins are written in rust, but are called from C in bash. Therefore it’s not easy to write them in a fashion that allows reuse and inter-builtin calls while also passing some form of mutable context parameter. Once again, pkgcraft uses a mutable, thread-local instance that builtins are able to import and use within closures to access and modify build data as required. While somewhat ugly, this does allow avoiding the even uglier bash variable hacks used by pkgcore.\n  Pkgcraft’s bash fork is available at https://github.com/pkgcraft/bash. ↩︎\n https://rust-lang.github.io/rfcs/2945-c-unwind-abi.html ↩︎\n   ","description":"","subtitle":"Mangling the shell for better integration","tags":["bash"],"title":"Extending bash","uri":"/posts/extending-bash/"},{"categories":null,"content":"Before beginning these grand timesink chronicles, allow me to review my historical use of Gentoo that helps explain this project’s existence. Note that this is pertains only to my experience and opinions.\n2005 – Getting sucked in I first installed Gentoo around 2005, near the probable peak of outward interest in the project. At this point no EAPIs existed, portage was the only choice, and the project felt exciting probably due to the level of interest at the time. From an outsider’s perspective, portage was doing an adequate job since core counts were low for consumer machines. Therefore, parallelization wasn’t overly important and improving the package tree was generally a higher priority.\nIn retrospect, the project should have capitalized more off the interest wave to explore other ideas before, in effect, chaining itself to bash for life. While I understand the upsides for selecting bash as a base, the downsides are quite large from a developer’s perspective as bash is highly focused on two things, running scripts and interactive shell usage. Its underlying structure leaves a lot to be desired when trying to force it outside those bounds.\n2010 – New package managers on the block Fast forward about 5 years to 2010 when EAPI 3 came out and two new package managers (pkgcore and paludis) joined portage, evolving as part of the specification process and proving its existence in aiding new development. Having tried both, I was impressed by the speed of pkgcore in relation to my experience with portage, both being mainly written in python. The main reasons for this runtime difference come from pkgcore’s more streamlined restriction framework, overall cleaner design, and ebuild daemon functionality that avoided re-execing bash as much as possible. Sadly enough, as more features made it into new EAPIs, pkgcore slowly fell behind mostly due to getting bus-factored into near stasis.\nAs could be discovered when trying out the alternative package managers, portage was starting to lag behind in a number of areas that it still suffers from including overall design and maintainability. While a number of features and performance improvements did find their way from pkgcore to portage around this time, in my opinion, Gentoo as a project should have thrown more support behind moving to or subsuming pkgcore because it would quickly become a nontrivial task in later years.\n2015 – Reviving a dying project 2015 was about the time I started getting involved in pkgcore-related development. For my part, most of my work on pkgcore and its related tools was due to curiosity, interest, and a hesitancy to let the project entirely die. Over the next few years I would drag pkgcore along, keeping it barely alive, culminating in rewriting pkgcheck (the pkgcore-based ebuild linter) nearly from scratch in an effort to parallelize it as much as its python-based nature allowed.\nDuring this time, it became apparent to me that Gentoo as a development community often felt directionless and highly change averse. Democratizing leadership while keeping the foundation separate lead to weak, overarching vision and therefore a rudderless appearance for the project. Personally I think the council should actively define priorities for the project and even use funding where appropriate to aid in that effort rather than its mainly reactionary and ratification style meetings.\n2020 onwards – Accepting fate By 2020, it had become clear to me that pkgcore and its related tools were evolutionary dead ends. I felt enough work had been done to prove their worth and underlying design was better than portage in a number of ways, but that wasn’t able to grow interest to a level where moving on from portage was feasible. In order to have had a better future, more focus should have been placed on merging pkgcore’s design with portage during the 2010 era when it was potentially feasible to do, by 2020 it was all but impossible.\nWith that in mind, I passed on maintenance to those with a vested interest in the project mainly due to Gentoo beginning to seriously use pkgcheck for CI against the main tree after the parallelization work was merged. I imagine the project will continue on life-support style maintenance as long as its alternative focuses on being an interactive commit tool, performing shockingly terrible at linting runs on any significant scale.\nRegarding my decision to drop pkgcore, in essence I never agreed with some of the underlying design and didn’t want to nearly rewrite it as I had been forced to for pkgcheck. For example, continuing in portage’s footsteps using an interpreted language like python for the core package manager felt like a poor long-term choice. At the time the fork occurred, it probably made sense but doesn’t anymore. In any case, if I was going to start over it would be drastically different than pkgcore from the outset.\nEnter… pkgcraft Having kicked around the idea of rewriting pkgcore in rust since early 2017, it slowly became a reality as the ecosystem grew enough where third party libraries existed to support the intended design. Whether it will surpass pkgcore’s efforts or fade away as an ephemeral dream remains to be seen, but hopefully these chronicles entertain, inform, or inspire others to support this timesink and strive towards their own.\n","description":"","subtitle":"Or How I Learned to Stop Procastinating and Waste More Time","tags":["Gentoo"],"title":"The Timesink Chronicles","uri":"/posts/timesink-chronicles/"}]